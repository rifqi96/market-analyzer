#!/usr/bin/env python3
"""
Market Analysis Main Script
--------------------------------------
This script runs the complete market analysis pipeline for any trading pair,
generating reports and visualizations for different timeframes.
"""

import os
import sys
import argparse
import json
from datetime import datetime

# Add the current directory to the Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Use the new market_analyzer package
from market_analyzer.config import (
    TIMEFRAMES, OUTPUT_DIR, DATA_DIR, CHARTS_DIR, 
    MARKET_TYPES, DEFAULT_MARKET_TYPE, DEFAULT_PAIRS, MARKET_APIS
)
from market_analyzer.data_fetcher import get_market_data
from market_analyzer.indicators import calculate_all_indicators
from market_analyzer.visualizer import setup_output_dirs, generate_all_charts
from market_analyzer.analyzer import analyze_all_timeframes
from market_analyzer.reporter import (
    save_analysis_json,
    generate_short_term_report,
    generate_monthly_report,
    generate_combined_report
)


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description='Market Technical Analysis')
    
    # Required argument for trading pair
    parser.add_argument(
        'trading_pair',
        nargs='?',  # Make it optional for backward compatibility
        default=None,
        help='Trading pair to analyze (e.g., BTCUSDT, AAPL, EURUSD, XAUUSD, GC=F)'
    )
    
    # Market type
    parser.add_argument(
        '--market-type',
        choices=[MARKET_TYPES['CRYPTO'], MARKET_TYPES['STOCK'], MARKET_TYPES['FOREX'], MARKET_TYPES['COMMODITY']],
        default=DEFAULT_MARKET_TYPE,
        help=f'Market type (default: {DEFAULT_MARKET_TYPE})'
    )
    
    parser.add_argument(
        '--timeframes', 
        nargs='+',
        choices=list(TIMEFRAMES.keys()),
        default=['1d', '1w'],
        help='Timeframes to analyze (default: 1d 1w)'
    )
    
    # Update source choices based on available sources for all market types
    all_sources = set()
    for market_type in MARKET_TYPES.values():
        if market_type in MARKET_APIS:
            for api in MARKET_APIS[market_type]:
                all_sources.add(api['name'])
    
    parser.add_argument(
        '--source',
        choices=list(all_sources),
        default=None,  # Will be set based on market type if not specified
        help='Data source (default: binance for crypto, yahoo_finance for stocks and commodities, alpha_vantage for forex)'
    )
    
    parser.add_argument(
        '--reports',
        nargs='+',
        choices=['short', 'monthly', 'combined', 'all'],
        default=['all'],
        help='Reports to generate (default: all)'
    )
    
    parser.add_argument(
        '--no-charts',
        action='store_false',
        dest='charts',
        help='Disable chart generation (charts are generated by default)'
    )
    
    parser.add_argument(
        '--output-dir',
        default=OUTPUT_DIR,
        help=f'Output directory (default: {OUTPUT_DIR})'
    )
    
    parser.add_argument(
        '--analysis-date',
        type=str,
        default=None,
        help='Date to analyze as if it were "today" (format: YYYY-MM-DD). Example: --analysis-date 2025-05-18 will analyze the market as it was on May 18, 2025'
    )
    
    return parser.parse_args()


def main():
    """Main function."""
    # Parse arguments
    args = parse_arguments()
    
    # If no trading pair is provided, use the default for the selected market type
    if args.trading_pair is None:
        args.trading_pair = DEFAULT_PAIRS.get(args.market_type, 'BTCUSDT')
    
    # Set default source based on market type if not specified
    if args.source is None:
        if args.market_type == MARKET_TYPES['CRYPTO']:
            args.source = 'binance'
        elif args.market_type == MARKET_TYPES['STOCK']:
            args.source = 'yahoo_finance'
        elif args.market_type == MARKET_TYPES['FOREX']:
            args.source = 'alpha_vantage' if 'alpha_vantage' in [api['name'] for api in MARKET_APIS.get(args.market_type, [])] else 'yahoo_finance'
        elif args.market_type == MARKET_TYPES['COMMODITY']:
            args.source = 'yahoo_finance'
    
    # Create market-specific output directories
    market_output_dir = os.path.join(args.output_dir, args.market_type, args.trading_pair)
    market_data_dir = os.path.join(market_output_dir, 'data')
    market_charts_dir = os.path.join(market_output_dir, 'charts')
    
    # Ensure output directories exist
    os.makedirs(market_output_dir, exist_ok=True)
    os.makedirs(market_data_dir, exist_ok=True)
    os.makedirs(market_charts_dir, exist_ok=True)
    
    print(f"Starting {args.market_type} analysis for {args.trading_pair} at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Analyzing timeframes: {', '.join(args.timeframes)}")
    print(f"Data source: {args.source}")
    
    # Fetch and process data for each timeframe
    dataframes = {}
    
    for timeframe in args.timeframes:
        print(f"\nProcessing {timeframe} timeframe...")
        
        # Fetch data
        try:
            print(f"Fetching {args.trading_pair} data for {timeframe} timeframe from {args.source}...")
            if args.analysis_date:
                print(f"Analyzing as of date: {args.analysis_date}")
            df = get_market_data(
                trading_pair=args.trading_pair,
                timeframe=timeframe,
                source=args.source,
                market_type=args.market_type,
                analysis_date=args.analysis_date
            )
            
            if df is None or len(df) == 0:
                print(f"Error: No data available for {timeframe} timeframe")
                continue
                
            print(f"Successfully fetched {len(df)} {timeframe} candles")
            
            # Calculate technical indicators with market-specific parameters
            print(f"Calculating technical indicators for {timeframe} timeframe...")
            df = calculate_all_indicators(df, market_type=args.market_type)
            
            # Store DataFrame
            dataframes[timeframe] = df
            
            # Generate charts if requested
            if args.charts:
                print(f"Generating charts for {timeframe} timeframe...")
                setup_output_dirs(charts_dir=market_charts_dir)
                generate_all_charts(df, timeframe, trading_pair=args.trading_pair, market_type=args.market_type, charts_dir=market_charts_dir)
                
        except Exception as e:
            print(f"Error processing {timeframe} timeframe: {str(e)}")
    
    if not dataframes:
        print("Error: No data available for analysis")
        return
    
    # Analyze data
    print(f"\nAnalyzing {args.trading_pair} data across timeframes...")
    analysis_results = analyze_all_timeframes(
        dataframes, 
        trading_pair=args.trading_pair,
        market_type=args.market_type,
        analysis_date=args.analysis_date
    )
    
    # Save analysis results
    print("Saving analysis results...")
    save_analysis_json(analysis_results, data_dir=market_data_dir)
    
    # Generate reports
    reports_to_generate = args.reports
    if 'all' in reports_to_generate:
        reports_to_generate = ['short', 'monthly', 'combined']
    
    for report_type in reports_to_generate:
        if report_type == 'short':
            print("Generating short-term forecast report...")
            generate_short_term_report(analysis_results, output_dir=market_output_dir)
        elif report_type == 'monthly':
            print("Generating monthly forecast report...")
            generate_monthly_report(analysis_results, output_dir=market_output_dir)
        elif report_type == 'combined':
            print("Generating combined forecast report...")
            generate_combined_report(analysis_results, output_dir=market_output_dir)
    
    print(f"\nAnalysis complete at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Results available in {market_output_dir}")


if __name__ == "__main__":
    main()
